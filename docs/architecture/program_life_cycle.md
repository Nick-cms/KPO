# Лабораторная работа №4
# Проект: "Умный дом"

## 1. Обоснование модели ЖЦ, наиболее подходящей для проекта
Для проекта "Умный дом" наиболее целесообразной моделью жизненного цикла является Итерационная модель или Гибкая методология разработки (Agile), например, в виде Scrum или Kanban.
Обоснование:
	- Неполнота и изменчивость требований. На начальном этапе сложно предусмотреть все функции, которые захотят пользователи (управление светом, отоплением, безопасностью, мультимедиа и т.д.). Требования будут уточняться и дополняться по мере разработки и получения обратной связи.
	- Поэтапная поставка ценности. Можно разбить проект на короткие циклы (итерации/спринты), по итогу каждой из которых будет готов работающий прототип с новыми функциями. Например:
	- Итерация 1: Базовая структура проекта, управление одним типом устройств (например, светом).
	- Итерация 2: Добавление системы безопасности (датчики движения).
	- Итерация 3: Интеграция с голосовым помощником.
	- Снижение рисков. Раннее тестирование рабочих прототипов позволяет выявить проблемы на начальных этапах, а не в конце проекта.
	- Гибкость. Модель позволяет быстро адаптироваться к изменениям на рынке или новым пожеланиям заказчика.
Эта модель соответствует духу стандарта ГОСТ Р ИСО/МЭК 12207-2010, который не навязывает конкретную модель, а рекомендует адаптировать процессы под нужды проекта.

## 2. Выделение этапов выполнения проекта в соответствии с ЖЦ
Используя итерационную модель и опираясь на процессы из ГОСТ Р ИСО/МЭК 12207-2010, выделим ключевые этапы для первой итерации проекта "Умный дом".
### Этап 1: Определение требований правообладателей (Stakeholder Requirements Definition)
	- Цель: Выяснить, что пользователи и заказчики ожидают от системы "Умный дом".
	- Действия:
	- Провести интервью с потенциальными пользователями.
	- Сформулировать список ключевых функций (управление светом, температурой, безопасностью).
	- Определить нефункциональные требования (производительность, безопасность, удобство использования).
	- Результат: Документ "Требования правообладателей".
### Этап 2: Анализ системных требований (System Requirements Analysis)
	- Цель: Превратить пожелания пользователей в конкретные технические спецификации.
	- Действия:
	- Детализировать требования к системе: "Система должна позволять включать/выключать свет дистанционно с мобильного приложения", "Система должна поддерживать устройства по протоколу Zigbee/Wi-Fi".
	- Определить компоненты системы: центральный хаб, датчики, исполнительные устройства (умные розетки, лампы), сервер, мобильное приложение.
	- Результат: "Спецификация системных требований".
### Этап 3: Проектирование архитектуры системы (System Architecture Design)
	- Цель: Определить, как компоненты системы будут взаимодействовать.
	- Действия:
	- Разработать высокоуровневую архитектуру: Мобильное приложение <-> Облачный сервер <-> Центральный хаб <-> Умные устройства.
	- Выбрать технологии и протоколы связи (Python/Node.js для сервера, MQTT для обмена сообщениями, React Native для приложения).
	- Спроектировать базу данных для хранения состояний устройств и сценариев.
	- Результат: "Архитектурная схема системы", "Техническое задание на разработку".
### Этап 4: Реализация (Implementation)
	- Цель: Создать программные компоненты системы.
	- Действия (для первой итерации):
	- Процесс конструирования программных средств: Написать код серверного API на Python (используя фреймворк FastAPI) для управления устройствами.
	- Процесс конструирования программных средств: Разработать простой интерфейс мобильного приложения (код на React Native) с кнопкой "Вкл/Выкл свет".
	- Написать прошивку для центрального хаба (условно, на C++), которая принимает команды от сервера и передает их на умную лампу.
	- Результат: Исходный код сервера, приложения и прошивки.
### Этап 5: Комплексирование системы (System Integration)
	- Цель: Собрать все компоненты в единую работающую систему.
	- Действия:
	- Развернуть облачный сервер и базу данных.
	- Запустить центральный хаб и подключить его к серверу.
	- Подключить умную лампу к хабу.
	- Установить мобильное приложение на телефон.
	- Настроить взаимодействие между всеми компонентами.
	- Результат: Интегрированный прототип системы "Умный дом".
### Этап 6: Квалификационное тестирование системы (System Qualification Testing)
	- Цель: Убедиться, что система соответствует требованиям.
	- Действия:
	- Провести тестирование: отправка команды из приложения -> проверка, что лампа загорается/гаснет.
	- Проверить задержку отклика.
	- Протестировать обработку ошибок (например, если хаб отключен от сети).
	- Результат: "Протокол тестирования", "Готовый к демонстрации прототип".

## 3. Провести кодирование и комплексную отладку ПО
### 3.1. Кодирование (на примере серверного API на Python с использованием FastAPI)
python

#### main.py (условный пример кода для сервера)
from fastapi import FastAPI
from pydantic import BaseModel

app = FastAPI()

#### Модель данных для команды
class DeviceCommand(BaseModel):
    device_id: str
    action: str  # "on" или "off"

#### "База данных" состояний устройств (в памяти для примера)
devices = {"lamp_1": "off"}

@app.post("/command")
async def send_command(command: DeviceCommand):
    # Логика отправки команды на хаб (здесь - имитация)
    devices[command.device_id] = command.action
    print(f"Command sent to hub: Set {command.device_id} to {command.action}")
    # Здесь был бы код для связи с хабом по MQTT или WebSocket
    return {"status": "success", "device_id": command.device_id, "new_state": command.action}

@app.get("/status/{device_id}")
async def get_status(device_id: str):
    return {"device_id": device_id, "state": devices.get(device_id, "unknown")}


### 3.2. Комплексная отладка
#### Шаг 1: Локальный запуск. Запустите сервер с помощью команды uvicorn main:app --reload.
#### Шаг 2: Тестирование API. Используйте Postman или Swagger UI (http://127.0.0.1:8000/docs) для отправки тестовых команд.
	- Запрос: POST /command с телом {"device_id": "lamp_1", "action": "on"}
	- Ожидаемый ответ: {"status":"success", "device_id":"lamp_1", "new_state":"on"}
	- Запрос: GET /status/lamp_1
	- Ожидаемый ответ: {"device_id":"lamp_1", "state":"on"}
#### Шаг 3: Интеграционная отладка.
	- Убедитесь, что мобильное приложение корректно отправляет HTTP-запросы на адрес вашего сервера.
	- Проверьте, что хаб (если он эмулируется) правильно получает и обрабатывает команды от сервера.
#### Шаг 4: Отладка сценариев.
	- Сценарий: "Пользователь нажимает кнопку вкл." -> Проверить, что приложение отправляет POST /command, сервер обрабатывает его и логирует команду, а состояние устройства в "базе данных" меняется на "on".
Результат пункта 3: Работающий прототип, состоящий из сервера (код выше), простого мобильного приложения и логики хаба, позволяющий включать и выключать виртуальную лампу. Весь код должен быть отлажен и протестирован.

Запустите систему
bash
cd /Users/macbook/Desktop/КПО
source smart_home_env/bin/activate
python smart_home_lab.py